📗 스프링 Spring
================
<hr />

> 스프링 이유와 원리에 대해 공부하고 객체지향 설계를 고민하는 개발자가 되자!

<br />

#### 주문 도메인 전체 그림

<img width="862" alt="전체그림" src="https://user-images.githubusercontent.com/68539040/182746470-66caf457-020c-442c-b3d8-a15235c0d56b.png">

- ```#1``` 문제점 발견
    + DIP 위반. ```OrderServiceImpl```은 ```DiscountPolicy``` 인터페이스에도 의존하고, 구현 클래스인  ```FixDiscountPolicy```
      와 ```RateDiscountPolicy```에도 의존하고 있다.
    + OCP 위반. ```FixDiscountPolicy```를 ```RateDiscountPolicy```로 변경하는 순간 ```OrderServiceImpl```코드도 변경해야 한다. 지금 코드는 기능을
      확장하면 클라이언트 코드에 영향을 주기 때문에 OCP를 위반함. <br />
      이에 대한 해결책으로 인터페이스에만 의존하게 하기 위해, ```OrderServiceImpl``` 코드를 아래처럼 바꿨다.  <br />
      (기존) ``` private final DiscountPolicy discountPolicy = new RateDiscountPolicy();``` <br />
      (변경) ``` private DiscountPolicy discountPolicy; ``` <br />
      하지만 이렇게 하면 당연히 객체 생성된게 없기 때문에.. nullpointerexception이 터진다. AppConfig 클래스를 생성해 DI(의존관계 주입)로 해결한다. <br /><br />
- 해결 : ```AppConfig```를 통해 코드 분리.(관심사 분리) ```AppConfig```가 구현클래스를 선택해 주게 되었기 때문에, 이제 ```OrderServiceImpl```는 기능을 실행하는
  책임만 지면 된다. <hr />


- ```#2``` 문제점 발견

- 해결 : ```AppConfig```에 중복 됐었던```new MemberRepository()```부분을 분리. 이제 다른 구현체로 변경할 때 이 부분만 변경하면 된다. 또 역할과 구현 클래스가 한 눈에
  들어와서 애플리케이션 전체 구성을 파악하기 좋아졌다. <hr />

### 좋은 객체 지향 설계의 5가지 원칙 적용

여기서 3가지 (SRP, DIP, OCP) 적용.

1. SRP 단일 책임 원칙 "한 클래스는 하나의 책임만"

- 클라이언트 객체는 직접 구현 객체를 생성, 연결, 실행하는 다양한 책임을 가지고 있음.
- SRP 단일 책임 원칙을 따르면서 관심사를 분리함.
- 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당.
- 클라이언트 객테는 실행하는 책임만 담당.

2. DIP 의존관계 역전 "프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나"

- 새로운 할인 정책을 개발하고, 적용하려고 하니 클라이어늩 코드도 변경해야 했다. 왜냐하면 기존 클라이언트 코드(```OrderServiceImpl```)은 DIP를 지키면서 ```DiscountPolicy```
  추상화 인터페이스에 의존하는 것 같았지만, ```FixDiscountPolicy```구체화 구현 서비스에도 함께 의존했다.
- 클라이언트 코드가 ```DiscountPolicy```추상화 인터페이스에만 의존하도록 코드를 변경했다.
- AppConfig가 ```FixDiscountPolicy``` 객체 인스턴스를 클라이언트 코드 대신 클라이언트 코드에 의존관계를 주입함. 이렇게 DIP 원칙을 따르면서 문제도 해결함.


3. OCP "소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다."

- 다형성을 사용하고 클라이언트가 DIP를 지킴.
- 애플리케이션을 사용 영역과 구성 영역으로 나눔.
- AppConfig가 의존관계를 ```FixDiscountPolicy```->```RateDiscountPolicy```로 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 됨. <br />
  즉, 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다. (변경할 필요X)

<hr />

### IoC, DI, 컨테이너

1. 제어의 역전 (IoC)

- 기존 프로그램은 클라이언트 구현객체가 스스로 필요한 서버 구현 객체를 생성, 연결, 실행했다. 한 마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조정한 것이다. 반면 ```AppConfig``` 생성 후에는
  구현 객체가 자신의 로직을 실행하는 역할만 담당한다. 프로그램 제어 흐름은 이제 AppConfig가 가져간다. 이렇게 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는
  것을 ```'제어의 역전'```이라고 한다.
- 프레임워크 vs 라이브러리? <br />
    - 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 프레임워크.(JUnit)
    - 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리.
      <br /><br />

2. 의존관계 주입 (DI)

- 애플리케이션 ```실행 시점(런타임)```에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 ```의존관계 주입```이라고 한다.
- 객체 인스턴스를 생성하고 그 참조값을 전달해서 연결된다.
- 의존관계 주입을 사용하면, 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 정적인 클래스 의존관계를 변경하지 않고(표면적인 애플리케이션 코드), 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
    + ```동적인 객체 인스턴스 의존 관계``` = 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계.
      <br /><br />

3. IoC 컨테이너, DI 컨테이너

- ```AppConfig```처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 ```IoC 컨테이너```또는```DI 컨테이너``` 라고 한다.
- 주입관계 주입에 초첨을 맞추어 최근에는 주로 DI 컨테이너라고 한다.
  <br /><br />

4. 스프링 컨테이너

- ```ApplicationContext```를 스프링 컨테이너라고 한다.
- 기존에는 개발자가 ```AppConfig```를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제 스프링 컨테이너를 통해 사용한다.
- 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정 정보로 사용한다. 여기서 Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 스프링 컨테이너에
  등록된 객체를 스프링 빈 이라고 한다. <br />
  기존에는 개발자가 직접 자바 코드로 오든 것을 했다면 이제 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에 스프링 빈을 찾아서 사용하도록 변경되었다.
- 코드가

5. 스프링 컨테이너와 스프링 빈 <br />
   (0) 스프링 컨테이너의 생성 과정<br />
   ```ApplicationContext applicationContext = new ApplicationContext(AppConfig.class)```
    - ApplicationContext 를 스프링 컨테이너 라고 한다. 이는 인터페이스 이다.
    - 스프링 컨테이너는 XML을 기반으로 만들 수 있고(요즘은 굳이 이렇게 안함), 어노테이션 기반의 자바 설정 클래스로 만들 수 있다.
    - 정확히는 스프링 컨테이너를 부를 때 'Bean Factory'와 'ApplicationContext'로 구분해서 말한다. Bean Factory를 직접 사용하는 경우는 없기 때문에 일반적으로
      ApplicationContext를 스프링 컨테이너라고 한다.
      <br /> <br />
      (1) 스프링 컨테이너의 생성 <br />
      ![IMG_386575ADA381-1](https://user-images.githubusercontent.com/68539040/182869070-05e36fca-6285-471b-8ca2-c7872e03017f.jpeg)
        - ```new ApplicationContext(AppConfig.class)```로 스프링 컨테이너를 만들고, key는 '빈 이름', 값은 '빈 객체'가 되어 저장된다.
        - 스프링 컨테이너를 생성할 때는 구성 정보를 지정해 주어야 한다. 여기서는 (AppConfig.class)를 파라미터로 넘긴 것. <br />
          <br />
          (2) 스프링빈 등록
          ![IMG_E73765EA00F2-1](https://user-images.githubusercontent.com/68539040/182869729-0d9750c3-2276-4ac7-8555-8842da262e36.jpeg)
          <br />
          빈 조회 시, 부모 타입으로 조회하면 자식 타입도 함께 조회된다.
          <br />  
          (3) 스프링빈 의존관계 설정 - 준비  <br />
          (4) 스프링빈 의존관계 설정 - 완료
          
          

    
